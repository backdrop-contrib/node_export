diff --git a/modules/node_export_relation/node_export_relation.node_reference.inc b/modules/node_export_relation/node_export_relation.node_reference.inc
diff --git a/modules/node_export_relation/node_export_relation.og.inc b/modules/node_export_relation/node_export_relation.og.inc
diff --git a/node_export.info b/node_export.info
index e3cba64..375b1ca 100755
--- a/node_export.info
+++ b/node_export.info
@@ -1,4 +1,5 @@
 name = Node export
 description = "Allows users to export a node and the import into another Drupal installation."
 core = 6.x
-package = "Node export"
\ No newline at end of file
+package = "Node export"
+dependencies[] = uuid
\ No newline at end of file
diff --git a/node_export.install b/node_export.install
index df30549..b14b077 100755
--- a/node_export.install
+++ b/node_export.install
@@ -13,7 +13,7 @@ function node_export_uninstall() {
   variable_del('node_export_code');
   variable_del('node_export_filename');
   variable_del('node_export_file_list');
-  variable_del('node_export_nodes_without_confirm');
+  variable_del('node_export_existing');
   $types = node_get_types('names');
   foreach ($types as $type => $name) {
     variable_del('node_export_reset_'. $type);
@@ -30,6 +30,7 @@ function node_export_uninstall() {
   variable_del('node_export_bulk_code');
   variable_del('node_export_bulk_filename');
   variable_del('node_export_omitted');
+  variable_del('node_export_nodes_without_confirm');
 }
 
 /**
diff --git a/node_export.module b/node_export.module
index 61f3346..7cbdd02 100755
--- a/node_export.module
+++ b/node_export.module
@@ -327,14 +327,13 @@ function node_export($nids, $format = NULL, $msg_t = 't') {
 function node_export_prepare_node(&$original_node) {
   // Create UUID if it's not there.
   // Currently this uses a module_exists() until UUID becomes a dependency.
-  if (module_exists('uuid')) {
-    if (!uuid_get_uuid('node', 'nid', $original_node->nid)) {
-      $original_node->uuid = uuid_set_uuid('node', 'nid', $original_node->nid);
-      // Save it so future node exports are consistent.
-      node_save($original_node);
-    }
+  if (!uuid_get_uuid('node', 'nid', $original_node->nid)) {
+    $original_node->uuid = uuid_set_uuid('node', 'nid', $original_node->nid);
+    // Save it so future node exports are consistent.
+    node_save($original_node);
   }
 
+
   $node = drupal_clone($original_node);
 
   // Fix taxonomy array
@@ -486,15 +485,40 @@ function node_export_import($code_string, $msg_t = 't') {
   $new_nid = 0;
   $messages = array();
   foreach ($nodes as $original_node) {
+    $skip = FALSE;
     $node = node_export_node_clone($original_node);
 
+    // Handle existing nodes.
+    $uuid_nid = node_export_node_get_by_uuid($node->uuid, TRUE);
+    if (!empty($uuid_nid)) {
+      $existing = variable_get('node_export_existing', 'new');
+      switch ($existing) {
+        case 'new':
+          $node->is_new = TRUE;
+          unset($node->nid);
+          unset($node->uuid);
+          break;
+        case 'revision':
+          $node->nid = $uuid_nid;
+          $node->is_new = FALSE;
+          $node->revision = 1;
+         break;
+        case 'skip':
+          $skip = TRUE;
+          break;
+      }
+    }
+
     // Let other modules do special fixing up.
     drupal_alter('node_export_node', $node, $original_node, 'import');
 
-    node_export_save($node);
-    $new_nodes[] = $node;
-    $messages[] = $msg_t("Imported node !nid: !node", array('!nid' => $node->nid, '!node' => l($node->title, 'node/'. $node->nid)));
-    $count++;
+    if (!$skip) {
+      node_export_save($node);
+      $new_nodes[] = $node;
+      $messages[] = $msg_t("Imported node !nid: !node", array('!nid' => $node->nid, '!node' => l($node->title, 'node/'. $node->nid)));
+      $count++;
+    }
+
   }
   drupal_alter('node_export', $new_nodes, 'after import', $used_format);
   $messages[] = $msg_t("!count of !total nodes were imported.  Some values may have been reset depending on Node export's configuration.", array('!total' => $total, '!count' => $count));
@@ -827,9 +851,9 @@ if (!function_exists('uuid_get_uuid')) {
  *   node_get_by_uuid() in uuid.module but does NOT uses db_rewrite_sql.
  *
  * @return
- *   Either the $node object, or FALSE on failure.
+ *   Either the $node object, nid, or FALSE on failure.
  */
-function node_export_node_get_by_uuid($uuid) {
+function node_export_node_get_by_uuid($uuid, $nid_only = FALSE) {
   $nid = db_result(db_query(
     "SELECT n.nid
      FROM {node} AS n
@@ -838,9 +862,12 @@ function node_export_node_get_by_uuid($uuid) {
     $uuid
   ));
 
-  if ($nid) {
+  if ($nid && !$nid_only) {
     return node_load($nid);
   }
+  else if ($nid) {
+    return $nid;
+  }
   else {
     return FALSE;
   }
diff --git a/node_export.pages.inc b/node_export.pages.inc
index 56ee81b..4801624 100755
--- a/node_export.pages.inc
+++ b/node_export.pages.inc
@@ -137,6 +137,18 @@ function node_export_settings() {
     '#description' => t('If there are more than this many nodes, the [nid-list] token for the filename will not be built.  This is to prevent very long filenames.'),
   );
 
+  $form['basic']['node_export_existing'] = array(
+    '#type' => 'radios',
+    '#title' => t('When importing a node that already exists'),
+    '#options' => array(
+      'new' => t('Create a new node'),
+      'revision' => t('Create a new revision of the existing node'),
+      'skip' => t('Skip the node'),
+    ),
+    '#description' => t('UUIDs are used to uniquely identify nodes.'),
+    '#default_value' => variable_get('node_export_existing', 'new'),
+  );
+
   $form['publishing'] = array(
     '#type' => 'fieldset',
     '#title' => t('Reset values on import'),
